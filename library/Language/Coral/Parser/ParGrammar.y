-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Language.Coral.Syntax.Parser.ParGrammar where
import Language.Coral.Syntax.Parser.AbsGrammar
import Language.Coral.Syntax.Parser.LexGrammar
import Language.Coral.Syntax.Parser.ErrM

}

%name pProgram Program
%name pIndentLine IndentLine
%name pStatement Statement
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!=' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '->' { PT _ (TS _ 10) }
  '.' { PT _ (TS _ 11) }
  '...' { PT _ (TS _ 12) }
  '.=' { PT _ (TS _ 13) }
  '/' { PT _ (TS _ 14) }
  '//' { PT _ (TS _ 15) }
  '0' { PT _ (TS _ 16) }
  ':' { PT _ (TS _ 17) }
  ';' { PT _ (TS _ 18) }
  '<' { PT _ (TS _ 19) }
  '<<' { PT _ (TS _ 20) }
  '<=' { PT _ (TS _ 21) }
  '=' { PT _ (TS _ 22) }
  '==' { PT _ (TS _ 23) }
  '=>' { PT _ (TS _ 24) }
  '>' { PT _ (TS _ 25) }
  '>=' { PT _ (TS _ 26) }
  '>>' { PT _ (TS _ 27) }
  '@' { PT _ (TS _ 28) }
  'False' { PT _ (TS _ 29) }
  'True' { PT _ (TS _ 30) }
  '[' { PT _ (TS _ 31) }
  ']' { PT _ (TS _ 32) }
  '^' { PT _ (TS _ 33) }
  'and' { PT _ (TS _ 34) }
  'as' { PT _ (TS _ 35) }
  'async' { PT _ (TS _ 36) }
  'await' { PT _ (TS _ 37) }
  'b' { PT _ (TS _ 38) }
  'break' { PT _ (TS _ 39) }
  'continue' { PT _ (TS _ 40) }
  'data' { PT _ (TS _ 41) }
  'def' { PT _ (TS _ 42) }
  'elif' { PT _ (TS _ 43) }
  'else' { PT _ (TS _ 44) }
  'except' { PT _ (TS _ 45) }
  'f' { PT _ (TS _ 46) }
  'finally' { PT _ (TS _ 47) }
  'for' { PT _ (TS _ 48) }
  'if' { PT _ (TS _ 49) }
  'in' { PT _ (TS _ 50) }
  'is' { PT _ (TS _ 51) }
  'j' { PT _ (TS _ 52) }
  'mut' { PT _ (TS _ 53) }
  'not' { PT _ (TS _ 54) }
  'or' { PT _ (TS _ 55) }
  'pass' { PT _ (TS _ 56) }
  'prop' { PT _ (TS _ 57) }
  'pub' { PT _ (TS _ 58) }
  'r' { PT _ (TS _ 59) }
  'return' { PT _ (TS _ 60) }
  'try' { PT _ (TS _ 61) }
  'type' { PT _ (TS _ 62) }
  'while' { PT _ (TS _ 63) }
  'with' { PT _ (TS _ 64) }
  '{' { PT _ (TS _ 65) }
  '|' { PT _ (TS _ 66) }
  '|>' { PT _ (TS _ 67) }
  '}' { PT _ (TS _ 68) }

L_doubl  { PT _ (TD $$) }
L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }
L_Con { PT _ (T_Con $$) }
L_Gen { PT _ (T_Gen $$) }
L_NAME { PT _ (T_NAME $$) }
L_Hexadecimal { PT _ (T_Hexadecimal $$) }
L_Octal { PT _ (T_Octal $$) }


%%

Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
String  :: { String }  : L_quoted {  $1 }
Con    :: { Con} : L_Con { Con ($1)}
Gen    :: { Gen} : L_Gen { Gen ($1)}
NAME    :: { NAME} : L_NAME { NAME ($1)}
Hexadecimal    :: { Hexadecimal} : L_Hexadecimal { Hexadecimal ($1)}
Octal    :: { Octal} : L_Octal { Octal ($1)}

Program :: { (Program ()) }
Program : ListDefinition { Language.Coral.Syntax.Parser.AbsGrammar.Prog () (reverse $1) }
NUMBER :: { (NUMBER ()) }
NUMBER : Double 'j' { Language.Coral.Syntax.Parser.AbsGrammar.ImagF () $1 }
       | Integer 'j' { Language.Coral.Syntax.Parser.AbsGrammar.ImagI () $1 }
       | NUMBER1 { $1 }
NUMBER1 :: { NUMBER () }
NUMBER1 : '0' { Language.Coral.Syntax.Parser.AbsGrammar.Zero () }
        | NUMBER2 { $1 }
NUMBER2 :: { NUMBER () }
NUMBER2 : Integer { Language.Coral.Syntax.Parser.AbsGrammar.Int () $1 }
        | NUMBER3 { $1 }
NUMBER3 :: { NUMBER () }
NUMBER3 : Hexadecimal { Language.Coral.Syntax.Parser.AbsGrammar.Hex () $1 }
        | NUMBER4 { $1 }
NUMBER4 :: { NUMBER () }
NUMBER4 : Double { Language.Coral.Syntax.Parser.AbsGrammar.Float () $1 }
        | '(' NUMBER ')' { $2 }
STRING :: { (STRING ()) }
STRING : String { Language.Coral.Syntax.Parser.AbsGrammar.Str () $1 }
       | STRING1 { $1 }
STRING1 :: { STRING () }
STRING1 : 'r' STRING { Language.Coral.Syntax.Parser.AbsGrammar.RawStr () $2 }
        | STRING2 { $1 }
STRING2 :: { STRING () }
STRING2 : 'f' STRING { Language.Coral.Syntax.Parser.AbsGrammar.FmtStr () $2 }
        | STRING3 { $1 }
STRING3 :: { STRING () }
STRING3 : 'b' STRING { Language.Coral.Syntax.Parser.AbsGrammar.ByteStr () $2 }
        | STRING4 { $1 }
STRING4 :: { STRING () }
STRING4 : STRING4 STRING { Language.Coral.Syntax.Parser.AbsGrammar.SplitStr () $1 $2 }
        | '(' STRING ')' { $2 }
Definition :: { (Definition ()) }
Definition : 'pub' AsyncDef { Language.Coral.Syntax.Parser.AbsGrammar.Definition1 () $2 }
           | 'pub' FuncDef { Language.Coral.Syntax.Parser.AbsGrammar.Definition2 () $2 }
           | 'pub' TypeDef { Language.Coral.Syntax.Parser.AbsGrammar.Definition3 () $2 }
           | 'pub' DataDef { Language.Coral.Syntax.Parser.AbsGrammar.Definition4 () $2 }
           | AsyncDef { Language.Coral.Syntax.Parser.AbsGrammar.DefinitionAsyncDef () $1 }
           | FuncDef { Language.Coral.Syntax.Parser.AbsGrammar.DefinitionFuncDef () $1 }
           | TypeDef { Language.Coral.Syntax.Parser.AbsGrammar.DefinitionTypeDef () $1 }
           | DataDef { Language.Coral.Syntax.Parser.AbsGrammar.DefinitionDataDef () $1 }
ListDefinition :: { [Definition ()] }
ListDefinition : {- empty -} { [] }
               | ListDefinition Definition { flip (:) $1 $2 }
Suite :: { (Suite ()) }
Suite : ':' '{' ListStatement '}' { Language.Coral.Syntax.Parser.AbsGrammar.Suite () $3 }
AsyncDef :: { (AsyncDef ()) }
AsyncDef : 'async' FuncDef { Language.Coral.Syntax.Parser.AbsGrammar.AsyncDef () $2 }
FuncDef :: { (FuncDef ()) }
FuncDef : 'def' NAME '(' ListParameter ')' '=>' Type Suite { Language.Coral.Syntax.Parser.AbsGrammar.FuncDef () $2 $4 $7 $8 }
IndentLine :: { (IndentLine ()) }
IndentLine : 'def' NAME '(' ListParameter ')' '=>' Type ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine1 () $2 $4 $7 }
           | 'if' BoolExpr ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine2 () $2 }
           | 'elif' BoolExpr ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine3 () $2 }
           | 'else' ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine4 () }
           | 'while' BoolExpr ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine5 () $2 }
           | 'for' ListTest 'in' ListTest ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine6 () $2 $4 }
           | 'try' ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine7 () }
           | 'except' ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine8 () }
           | 'finally' ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine9 () }
           | 'try' 'with' ListTest ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine10 () $3 }
           | 'except' ListExceptClause ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine11 () $2 }
           | 'type' TypeName ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine12 () $2 }
           | 'data' TypeName ':' { Language.Coral.Syntax.Parser.AbsGrammar.IndentLine13 () $2 }
Type :: { (Type ()) }
Type : 'mut' Type1 { Language.Coral.Syntax.Parser.AbsGrammar.MutType () $2 }
     | Type1 { $1 }
Type1 :: { Type () }
Type1 : Con '[' ListType ']' { Language.Coral.Syntax.Parser.AbsGrammar.GenericType () $1 $3 }
      | Type2 { $1 }
Type2 :: { Type () }
Type2 : Con { Language.Coral.Syntax.Parser.AbsGrammar.ConcreteType () $1 }
      | Type3 { $1 }
Type3 :: { Type () }
Type3 : Gen { Language.Coral.Syntax.Parser.AbsGrammar.ParamType () $1 }
      | Type4 { $1 }
Type4 :: { Type () }
Type4 : '(' ListType ')' '=>' Type { Language.Coral.Syntax.Parser.AbsGrammar.FunType () $2 $5 }
      | '(' Type ')' { $2 }
ListType :: { [Type ()] }
ListType : {- empty -} { [] }
         | Type { (:[]) $1 }
         | Type ',' ListType { (:) $1 $3 }
ArgType :: { (ArgType ()) }
ArgType : Type { Language.Coral.Syntax.Parser.AbsGrammar.ArgTypeType () $1 }
        | '...' Type { Language.Coral.Syntax.Parser.AbsGrammar.ArgType1 () $2 }
VarType :: { (VarType ()) }
VarType : {- empty -} { Language.Coral.Syntax.Parser.AbsGrammar.IType () }
        | ':' Type { Language.Coral.Syntax.Parser.AbsGrammar.EType () $2 }
Parameter :: { (Parameter ()) }
Parameter : NAME ':' ArgType { Language.Coral.Syntax.Parser.AbsGrammar.Parameter1 () $1 $3 }
          | NAME ':' ArgType '=' Test { Language.Coral.Syntax.Parser.AbsGrammar.Parameter2 () $1 $3 $5 }
          | '...' NAME ':' '*' ArgType { Language.Coral.Syntax.Parser.AbsGrammar.Parameter3 () $2 $5 }
ListParameter :: { [Parameter ()] }
ListParameter : {- empty -} { [] }
              | Parameter { (:[]) $1 }
              | Parameter ',' ListParameter { (:) $1 $3 }
ListStatement :: { [Statement ()] }
ListStatement : Statement { (:[]) $1 }
              | Statement ';' ListStatement { (:) $1 $3 }
TypeDef :: { (TypeDef ()) }
TypeDef : 'type' TypeName ':' '{' ListConstructor '}' { Language.Coral.Syntax.Parser.AbsGrammar.ADTDef () $2 $5 }
        | 'type' TypeName ':' '{' ListField '}' { Language.Coral.Syntax.Parser.AbsGrammar.RecDef () $2 $5 }
TypeName :: { (TypeName ()) }
TypeName : Con '[' ListType ']' { Language.Coral.Syntax.Parser.AbsGrammar.GenName () $1 $3 }
         | TypeName1 { $1 }
TypeName1 :: { TypeName () }
TypeName1 : Con { Language.Coral.Syntax.Parser.AbsGrammar.Name () $1 }
          | '(' TypeName ')' { $2 }
Constructor :: { (Constructor ()) }
Constructor : Con '(' ListCField ')' { Language.Coral.Syntax.Parser.AbsGrammar.Product () $1 $3 }
            | Constructor1 { $1 }
Constructor1 :: { Constructor () }
Constructor1 : Con { Language.Coral.Syntax.Parser.AbsGrammar.Term () $1 }
             | '(' Constructor ')' { $2 }
ListConstructor :: { [Constructor ()] }
ListConstructor : Constructor { (:[]) $1 }
                | Constructor ';' ListConstructor { (:) $1 $3 }
Field :: { (Field ()) }
Field : NAME ':' Type { Language.Coral.Syntax.Parser.AbsGrammar.Field () $1 $3 }
CField :: { (CField ()) }
CField : Type { Language.Coral.Syntax.Parser.AbsGrammar.CFieldType () $1 }
       | Field { Language.Coral.Syntax.Parser.AbsGrammar.CFieldField () $1 }
ListField :: { [Field ()] }
ListField : Field { (:[]) $1 } | Field ';' ListField { (:) $1 $3 }
ListCField :: { [CField ()] }
ListCField : CField { (:[]) $1 }
           | CField ',' ListCField { (:) $1 $3 }
DataDef :: { (DataDef ()) }
DataDef : 'data' TypeName ':' '{' ListDataField '}' { Language.Coral.Syntax.Parser.AbsGrammar.DataDef () $2 $5 }
DataField :: { (DataField ()) }
DataField : Prop { Language.Coral.Syntax.Parser.AbsGrammar.DataFieldProp () $1 }
          | FuncDef { Language.Coral.Syntax.Parser.AbsGrammar.DataFieldFuncDef () $1 }
ListDataField :: { [DataField ()] }
ListDataField : DataField { (:[]) $1 }
              | DataField ';' ListDataField { (:) $1 $3 }
Prop :: { (Prop ()) }
Prop : 'prop' NAME ':' Type { Language.Coral.Syntax.Parser.AbsGrammar.Prop () $2 $4 }
Statement :: { (Statement ()) }
Statement : Expr { Language.Coral.Syntax.Parser.AbsGrammar.Expr () $1 }
          | FuncDef { Language.Coral.Syntax.Parser.AbsGrammar.SFuncDef () $1 }
          | AsyncDef { Language.Coral.Syntax.Parser.AbsGrammar.SAFuncDef () $1 }
          | Test '=' Expr { Language.Coral.Syntax.Parser.AbsGrammar.Assign () $1 $3 }
          | Test '.=' Expr { Language.Coral.Syntax.Parser.AbsGrammar.MutAssign () $1 $3 }
          | NAME VarType '=' Expr { Language.Coral.Syntax.Parser.AbsGrammar.DefVal () $1 $2 $4 }
          | NAME VarType { Language.Coral.Syntax.Parser.AbsGrammar.Def () $1 $2 }
          | 'mut' NAME VarType '=' Expr { Language.Coral.Syntax.Parser.AbsGrammar.MutDefVal () $2 $3 $5 }
          | 'mut' NAME VarType { Language.Coral.Syntax.Parser.AbsGrammar.MutDef () $2 $3 }
          | 'return' ListTestStarExpr { Language.Coral.Syntax.Parser.AbsGrammar.Return () $2 }
          | 'while' BoolExpr Suite 'else' Suite { Language.Coral.Syntax.Parser.AbsGrammar.WhileElse () $2 $3 $5 }
          | 'while' BoolExpr Suite { Language.Coral.Syntax.Parser.AbsGrammar.While () $2 $3 }
          | 'for' ListTest 'in' ListTest Suite 'else' Suite { Language.Coral.Syntax.Parser.AbsGrammar.ForElse () $2 $4 $5 $7 }
          | 'for' ListTest 'in' ListTest Suite { Language.Coral.Syntax.Parser.AbsGrammar.For () $2 $4 $5 }
          | 'if' BoolExpr Suite ListElif 'else' Suite { Language.Coral.Syntax.Parser.AbsGrammar.IfElse () $2 $3 (reverse $4) $6 }
          | 'if' BoolExpr Suite ListElif { Language.Coral.Syntax.Parser.AbsGrammar.IfElif () $2 $3 (reverse $4) }
          | 'if' BoolExpr Suite { Language.Coral.Syntax.Parser.AbsGrammar.If () $2 $3 }
          | 'try' Suite ListExcept 'else' Suite 'finally' Suite { Language.Coral.Syntax.Parser.AbsGrammar.TryEFin () $2 (reverse $3) $5 $7 }
          | 'try' 'with' ListTest Suite ListExcept 'else' Suite 'finally' Suite { Language.Coral.Syntax.Parser.AbsGrammar.TryWEFin () $3 $4 (reverse $5) $7 $9 }
          | 'try' Suite ListExcept 'else' Suite { Language.Coral.Syntax.Parser.AbsGrammar.TryElse () $2 (reverse $3) $5 }
          | 'try' 'with' ListTest Suite ListExcept 'else' Suite { Language.Coral.Syntax.Parser.AbsGrammar.TryWElse () $3 $4 (reverse $5) $7 }
          | 'try' Suite ListExcept { Language.Coral.Syntax.Parser.AbsGrammar.Try () $2 (reverse $3) }
          | 'try' 'with' ListTest Suite ListExcept { Language.Coral.Syntax.Parser.AbsGrammar.TryWith () $3 $4 (reverse $5) }
          | 'break' { Language.Coral.Syntax.Parser.AbsGrammar.Break () }
          | 'continue' { Language.Coral.Syntax.Parser.AbsGrammar.Continue () }
          | 'pass' { Language.Coral.Syntax.Parser.AbsGrammar.Pass () }
Elif :: { (Elif ()) }
Elif : 'elif' BoolExpr Suite { Language.Coral.Syntax.Parser.AbsGrammar.Elif () $2 $3 }
ListElif :: { [Elif ()] }
ListElif : {- empty -} { [] } | ListElif Elif { flip (:) $1 $2 }
Except :: { (Except ()) }
Except : 'except' Suite { Language.Coral.Syntax.Parser.AbsGrammar.EExcp () $2 }
       | 'except' ListExceptClause Suite { Language.Coral.Syntax.Parser.AbsGrammar.Excp () $2 $3 }
ListExcept :: { [Except ()] }
ListExcept : {- empty -} { [] }
           | ListExcept Except { flip (:) $1 $2 }
ExceptClause :: { (ExceptClause ()) }
ExceptClause : TypeName 'as' NAME { Language.Coral.Syntax.Parser.AbsGrammar.EClauseAs () $1 $3 }
             | TypeName { Language.Coral.Syntax.Parser.AbsGrammar.EClause () $1 }
ListExceptClause :: { [ExceptClause ()] }
ListExceptClause : ExceptClause { (:[]) $1 }
                 | ExceptClause ',' ListExceptClause { (:) $1 $3 }
BoolExpr :: { (BoolExpr ()) }
BoolExpr : Expr2 { Language.Coral.Syntax.Parser.AbsGrammar.BoolExpr () $1 }
BoolOp :: { (BoolOp ()) }
BoolOp : 'and' { Language.Coral.Syntax.Parser.AbsGrammar.And () }
       | 'or' { Language.Coral.Syntax.Parser.AbsGrammar.Or () }
CompOp :: { (CompOp ()) }
CompOp : 'in' { Language.Coral.Syntax.Parser.AbsGrammar.In () }
       | 'not' 'in' { Language.Coral.Syntax.Parser.AbsGrammar.NotIn () }
       | 'is' { Language.Coral.Syntax.Parser.AbsGrammar.Is () }
       | '<' { Language.Coral.Syntax.Parser.AbsGrammar.Lt () }
       | '<=' { Language.Coral.Syntax.Parser.AbsGrammar.Le () }
       | '>' { Language.Coral.Syntax.Parser.AbsGrammar.Gt () }
       | '>=' { Language.Coral.Syntax.Parser.AbsGrammar.Ge () }
       | '!=' { Language.Coral.Syntax.Parser.AbsGrammar.Ne () }
       | '==' { Language.Coral.Syntax.Parser.AbsGrammar.Eq () }
StarExpr :: { (StarExpr ()) }
StarExpr : '*' Expr { Language.Coral.Syntax.Parser.AbsGrammar.Star () $2 }
Expr :: { (Expr ()) }
Expr : 'try' Expr2 { Language.Coral.Syntax.Parser.AbsGrammar.TryExpr () $2 }
     | Expr1 { $1 }
Expr1 :: { Expr () }
Expr1 : 'await' Expr { Language.Coral.Syntax.Parser.AbsGrammar.AwaitExpr () $2 }
      | Expr2 { $1 }
Expr2 :: { Expr () }
Expr2 : Expr2 Op Expr7 { Language.Coral.Syntax.Parser.AbsGrammar.OpExpr () $1 $2 $3 }
      | Expr3 { $1 }
Expr3 :: { Expr () }
Expr3 : 'not' Expr4 { Language.Coral.Syntax.Parser.AbsGrammar.NotExpr () $2 }
      | Expr4 { $1 }
Expr4 :: { Expr () }
Expr4 : Expr4 BoolOp Expr { Language.Coral.Syntax.Parser.AbsGrammar.BOpExpr () $1 $2 $3 }
      | Expr5 { $1 }
Expr5 :: { Expr () }
Expr5 : Expr CompOp Expr { Language.Coral.Syntax.Parser.AbsGrammar.COpExpr () $1 $2 $3 }
      | Expr6 { $1 }
Expr6 :: { Expr () }
Expr6 : 'True' { Language.Coral.Syntax.Parser.AbsGrammar.LTrue () }
      | 'False' { Language.Coral.Syntax.Parser.AbsGrammar.LFalse () }
      | Expr7 { $1 }
Expr7 :: { Expr () }
Expr7 : Test { Language.Coral.Syntax.Parser.AbsGrammar.TestExpr () $1 }
      | '(' Expr ')' { $2 }
Op :: { (Op ()) }
Op : '*' { Language.Coral.Syntax.Parser.AbsGrammar.Mul () }
   | '@' { Language.Coral.Syntax.Parser.AbsGrammar.MMul () }
   | '/' { Language.Coral.Syntax.Parser.AbsGrammar.Div () }
   | '//' { Language.Coral.Syntax.Parser.AbsGrammar.FDiv () }
   | '%' { Language.Coral.Syntax.Parser.AbsGrammar.Mod () }
   | '+' { Language.Coral.Syntax.Parser.AbsGrammar.Add () }
   | '-' { Language.Coral.Syntax.Parser.AbsGrammar.Minus () }
   | '<<' { Language.Coral.Syntax.Parser.AbsGrammar.LShift () }
   | '>>' { Language.Coral.Syntax.Parser.AbsGrammar.RShift () }
   | '&' { Language.Coral.Syntax.Parser.AbsGrammar.BitAnd () }
   | '^' { Language.Coral.Syntax.Parser.AbsGrammar.BitXor () }
   | '|' { Language.Coral.Syntax.Parser.AbsGrammar.BitOr () }
   | '->' { Language.Coral.Syntax.Parser.AbsGrammar.APipe () }
   | '|>' { Language.Coral.Syntax.Parser.AbsGrammar.Pipe () }
Test :: { (Test ()) }
Test : NAME ListTrailer { Language.Coral.Syntax.Parser.AbsGrammar.Test1 () $1 $2 }
     | NAME { Language.Coral.Syntax.Parser.AbsGrammar.TestNAME () $1 }
     | NUMBER { Language.Coral.Syntax.Parser.AbsGrammar.TestNUMBER () $1 }
     | STRING { Language.Coral.Syntax.Parser.AbsGrammar.TestSTRING () $1 }
ListTest :: { [Test ()] }
ListTest : Test { (:[]) $1 } | Test ',' ListTest { (:) $1 $3 }
Trailer :: { (Trailer ()) }
Trailer : '(' ListArg ')' { Language.Coral.Syntax.Parser.AbsGrammar.Trailer1 () $2 }
        | '[' Subscript ']' { Language.Coral.Syntax.Parser.AbsGrammar.Trailer2 () $2 }
        | '.' NAME { Language.Coral.Syntax.Parser.AbsGrammar.Trailer3 () $2 }
ListTrailer :: { [Trailer ()] }
ListTrailer : Trailer { (:[]) $1 }
            | Trailer ListTrailer { (:) $1 $2 }
Subscript :: { (Subscript ()) }
Subscript : Test { Language.Coral.Syntax.Parser.AbsGrammar.SubscriptTest () $1 }
          | Test ':' Test ':' Test { Language.Coral.Syntax.Parser.AbsGrammar.Subscript1 () $1 $3 $5 }
          | ':' Test ':' Test { Language.Coral.Syntax.Parser.AbsGrammar.Subscript2 () $2 $4 }
          | Test ':' ':' Test { Language.Coral.Syntax.Parser.AbsGrammar.Subscript3 () $1 $4 }
          | Test ':' Test ':' { Language.Coral.Syntax.Parser.AbsGrammar.Subscript4 () $1 $3 }
          | Test ':' ':' { Language.Coral.Syntax.Parser.AbsGrammar.Subscript5 () $1 }
          | ':' Test ':' { Language.Coral.Syntax.Parser.AbsGrammar.Subscript6 () $2 }
          | ':' ':' Test { Language.Coral.Syntax.Parser.AbsGrammar.Subscript7 () $3 }
ListSubscript :: { [Subscript ()] }
ListSubscript : Subscript { (:[]) $1 }
              | Subscript ',' ListSubscript { (:) $1 $3 }
Arg :: { (Arg ()) }
Arg : Expr { Language.Coral.Syntax.Parser.AbsGrammar.ArgExpr () $1 }
    | NAME '=' Test { Language.Coral.Syntax.Parser.AbsGrammar.Arg1 () $1 $3 }
    | '...' Test { Language.Coral.Syntax.Parser.AbsGrammar.Arg2 () $2 }
ListArg :: { [Arg ()] }
ListArg : {- empty -} { [] }
        | Arg { (:[]) $1 }
        | Arg ',' ListArg { (:) $1 $3 }
TestStarExpr :: { (TestStarExpr ()) }
TestStarExpr : Test { Language.Coral.Syntax.Parser.AbsGrammar.TestStarExprTest () $1 }
             | StarExpr { Language.Coral.Syntax.Parser.AbsGrammar.TestStarExprStarExpr () $1 }
ListTestStarExpr :: { [TestStarExpr ()] }
ListTestStarExpr : {- empty -} { [] }
                 | TestStarExpr { (:[]) $1 }
                 | TestStarExpr ',' ListTestStarExpr { (:) $1 $3 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

