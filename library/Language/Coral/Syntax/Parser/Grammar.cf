comment ";;";

layout ":";

entrypoints Program, IndentLine, Statement;
Prog. Program ::= [Definition];

token Con upper (letter | digit | '_' | '-' | '\'')*;
token Gen ('\'' lower (lower | digit)*);

token NAME letter (letter | digit | '_' | '-' | '\'')*;


token Hexadecimal '0' ('x'|'X') (digit | ["abcdef"] | ["ABCDEF"])+;
token Octal '0'["01234567"]*;

ImagF. NUMBER  ::= Double "j";
ImagI. NUMBER  ::= Integer "j";
Zero.  NUMBER1 ::= "0";
Int.   NUMBER2 ::= Integer;
Hex.   NUMBER3 ::= Hexadecimal;
Float. NUMBER4 ::= Double;
coercions NUMBER 4;

Str.     STRING   ::= String;
RawStr.  STRING1  ::= "r" STRING;
FmtStr.  STRING2  ::= "f" STRING;
ByteStr. STRING3  ::= "b" STRING;
SplitStr. STRING4 ::= STRING4 STRING;
coercions STRING 4;


rules Definition ::= "pub" AsyncDef | "pub" FuncDef | "pub" TypeDef | "pub" DataDef
                   | AsyncDef | FuncDef | TypeDef | DataDef;
separator Definition "";

Suite. Suite ::= ":" "{" [Statement] "}";
AsyncDef. AsyncDef ::= "async" FuncDef;
FuncDef. FuncDef ::= "def" NAME "(" [Parameter] ")" "=>" Type Suite;
rules IndentLine ::= "def" NAME "(" [Parameter] ")" "=>" Type ":"
                   | "if" BoolExpr ":"
                   | "elif" BoolExpr ":"
                   | "else" ":"
                   | "while" BoolExpr ":"
                   | "for" [Test] "in" [Test] ":"
                   | "try" ":"
                   | "except" ":"
                   | "finally" ":"
                   | "try" "with" [Test] ":"
                   | "except" [ExceptClause] ":"
                   | "type" TypeName ":"
                   | "data" TypeName ":";

MutType.      Type ::= "mut" Type1;
GenericType.  Type1 ::= Con "[" [Type] "]";
ConcreteType. Type2 ::= Con;
ParamType.    Type3 ::= Gen;
FunType.      Type4 ::= "(" [Type] ")" "=>" Type;
separator Type ",";
coercions Type 4;

rules ArgType ::= Type | "..." Type;
IType. VarType ::=;
EType. VarType ::= ":" Type;

rules Parameter ::= NAME ":" ArgType
                  | NAME ":" ArgType "=" Test
                  | "..." NAME ":" "*" ArgType;
separator Parameter ",";

separator nonempty Statement ";";


-- Types
ADTDef. TypeDef ::= "type" TypeName ":" "{" [Constructor] "}";
RecDef. TypeDef ::= "type" TypeName ":" "{" [Field] "}";

GenName. TypeName  ::= Con "[" [Type] "]";
Name.    TypeName1 ::= Con;
coercions TypeName 1;

Product. Constructor  ::= Con "(" [CField] ")";
Term.    Constructor1 ::= Con;
coercions Constructor 1;
separator nonempty Constructor ";";


Field. Field ::= NAME ":" Type;
rules CField ::= Type | Field;

separator nonempty Field ";";
separator nonempty CField ",";

-- Data Types
DataDef. DataDef ::= "data" TypeName ":" "{" [DataField] "}";

rules DataField ::= Prop | FuncDef;
separator nonempty DataField ";";

Prop. Prop ::= "prop" NAME ":" Type;

-- Statements

Expr.      Statement ::= Expr;
SFuncDef.  Statement ::= FuncDef;
SAFuncDef. Statement ::= AsyncDef;

-- Assign
Assign.    Statement ::= Test "=" Expr;
MutAssign. Statement ::= Test ".=" Expr;

-- Definitions
DefVal.    Statement ::= NAME VarType "=" Expr;
Def.       Statement ::= NAME VarType;
MutDefVal. Statement ::= "mut" NAME VarType "=" Expr;
MutDef.    Statement ::= "mut" NAME VarType;

-- Return
Return.    Statement ::= "return" [TestStarExpr];

-- While Statement
WhileElse. Statement ::= "while" BoolExpr Suite "else" Suite;
While.     Statement ::= "while" BoolExpr Suite;

-- For Statement
ForElse.   Statement ::= "for" [Test] "in" [Test] Suite "else" Suite;
For.       Statement ::= "for" [Test] "in" [Test] Suite;

-- If Statement
IfElse.    Statement ::= "if" BoolExpr Suite [Elif] "else" Suite;
IfElif.    Statement ::= "if" BoolExpr Suite [Elif];
If.        Statement ::= "if" BoolExpr Suite;

Elif. Elif ::= "elif" BoolExpr Suite;
separator Elif "";

-- Try Statement
TryEFin.   Statement ::= "try" Suite [Except] "else" Suite "finally" Suite;
TryWEFin.  Statement ::= "try" "with" [Test] Suite [Except] "else" Suite "finally" Suite;
TryElse.   Statement ::= "try" Suite [Except] "else" Suite;
TryWElse.  Statement ::= "try" "with" [Test] Suite [Except] "else" Suite;
Try.       Statement ::= "try" Suite [Except];
TryWith.   Statement ::= "try" "with" [Test] Suite [Except];

EExcp. Except ::= "except" Suite;
Excp.  Except ::= "except" [ExceptClause] Suite;
separator Except "";

EClauseAs. ExceptClause ::= TypeName "as" NAME;
EClause.   ExceptClause ::= TypeName;
separator nonempty ExceptClause ",";

-- Keywords
Break.     Statement ::= "break";
Continue.  Statement ::= "continue";
Pass.      Statement ::= "pass";

-- Boolean Expressions
BoolExpr. BoolExpr ::= Expr2;
-- coercions BoolExpr 4;

-- Bool Operators
And. BoolOp ::= "and";
Or.  BoolOp ::= "or";

-- Comparison Operators
In.    CompOp ::= "in";
NotIn. CompOp ::= "not in";
Is.    CompOp ::= "is";
Lt.    CompOp ::= "<";
Le.    CompOp ::= "<=";
Gt.    CompOp ::= ">";
Ge.    CompOp ::= ">=";
Ne.    CompOp ::= "!=";
Eq.    CompOp ::= "==";

-- Expressions
Star. StarExpr ::= "*" Expr;

-- BoolExpr.  Expr  ::= BoolExpr;
TryExpr.   Expr  ::= "try" Expr2;
AwaitExpr. Expr1 ::= "await" Expr;
OpExpr.    Expr2 ::= Expr2 Op Expr7;
NotExpr.   Expr3 ::= "not" Expr4;
BOpExpr.   Expr4 ::= Expr4 BoolOp Expr;
COpExpr.   Expr5 ::= Expr CompOp Expr;
LTrue.     Expr6 ::= "True";
LFalse.    Expr6 ::= "False";
TestExpr.  Expr7 ::= Test;
coercions Expr 7;


-- Expressions Operators
Mul.    Op ::= "*";
MMul.   Op ::= "@";
Div.    Op ::= "/";
FDiv.   Op ::= "//";
Mod.    Op ::= "%";

Add.    Op ::= "+";
Minus.  Op ::= "-";

LShift. Op ::= "<<";
RShift. Op ::= ">>";

BitAnd. Op ::= "&";

BitXor. Op ::= "^";

BitOr.  Op ::= "|";

APipe.  Op ::= "->";
Pipe.   Op ::= "|>";

rules Test ::= NAME [Trailer] | NAME | NUMBER | STRING;
separator nonempty Test ",";

-- Call, Indexing and Field Access
rules Trailer ::= "(" [Arg] ")" | "[" Subscript "]" | "." NAME;
separator nonempty Trailer "";
rules Subscript ::= Test
                  | Test ":" Test ":" Test
                  | ":" Test ":" Test
                  | Test ":" ":" Test
                  | Test ":" Test ":"
                  | Test ":" ":"
                  | ":" Test ":"
                  | ":" ":" Test;
separator nonempty Subscript ",";

rules Arg ::= Expr
            | NAME "=" Test
            | "..." Test;
separator Arg ",";

-- Literals

rules TestStarExpr ::= Test | StarExpr;
separator TestStarExpr ",";
